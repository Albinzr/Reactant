<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/style.css?t=615badd5">
    <script src="../assets/script.js?t=36f3d457"></script>
    <script src="../scripts/zopim.js?t=f160c13c"></script>
    <title>Architecture - Reactant</title>
    <meta name="viewport" content="width=device-width">
    <script>if (false || window.location.hostname.indexOf("docs.reactant.tech") === window.location.hostname.length - 18) {
        (function(d,o,c,p,r,e,s){d['GoogleAnalyticsObject']=r;d[r]=d[r]||function(){(d[r].q=d[r].q||[]).push(arguments)},d[r].l=1*new Date();e=o.createElement(c),s=o.getElementsByTagName(c)[0];e.async=1;e.src=p;s.parentNode.insertBefore(e,s)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create',"UA-48374666-17",'auto')
      }
    </script>
  </head>
  <body class="-menu-visible">
    <div class="doc-layout">
      <div class="toggle menu-toggle js-menu-toggle"></div>
      <div class="menu toc-menu">
        <li class="menu-item -level-0 -parent">
          <ul class="submenu">
            <li class="menu-item -level-1"><a class="link title  link-index" href="../index.html">Reactant</a>
            </li>
            <li class="menu-item -level-1 -parent"><span class="title">Getting started</span>
              <ul class="submenu">
                <li class="menu-item -level-2"><a class="link title  link-getting-startedquickstart" href="../getting-started/quickstart.html">Quick-start guide</a>
                </li>
                <li class="menu-item -level-2"><a class="link title -active link-getting-startedarchitecture" href="../getting-started/architecture.html">Architecture</a>
                  <ul class="headings heading-list">
                    <li class="heading-item -depth-2"><a class="hlink link-recommended-directory-structure" href="#recommended-directory-structure">Recommended directory structure</a>
                      <ul class="heading-list -depth-2">
                        <li class="heading-item -depth-3"><a class="hlink link-rootview" href="#rootview">RootView</a>
                        </li>
                        <li class="heading-item -depth-3"><a class="hlink link-controller" href="#controller">Controller</a>
                        </li>
                      </ul>
                    </li>
                    <li class="heading-item -depth-2"><a class="hlink link-dependency-injection-parameters-and-reactions" href="#dependency-injection-parameters-and-reactions">Dependency Injection, Parameters, and Reactions</a>
                    </li>
                    <li class="heading-item -depth-2"><a class="hlink link-service" href="#service">Service</a>
                    </li>
                    <li class="heading-item -depth-2"><a class="hlink link-dependency-module" href="#dependency-module">Dependency Module</a>
                    </li>
                    <li class="heading-item -depth-2"><a class="hlink link-wireframe" href="#wireframe">Wireframe</a>
                    </li>
                    <li class="heading-item -depth-2"><a class="hlink link-final-result" href="#final-result">Final result</a>
                    </li>
                  </ul>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-getting-startedtroubleshooting" href="../getting-started/troubleshooting.html">Troubleshooting</a>
                </li>
              </ul>
            </li>
            <li class="menu-item -level-1 -parent"><span class="title">Tutorials</span>
              <ul class="submenu">
                <li class="menu-item -level-2"><a class="link title  link-tutorialsrnotesnotes" href="../tutorials/RNotes/notes.html">Simple note taking app</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-tutorialsgitxplorerexplorer" href="../tutorials/GitXplorer/explorer.html">Random GitHub users explorer</a>
                </li>
              </ul>
            </li>
            <li class="menu-item -level-1 -parent"><span class="title">Reactant UI</span>
              <ul class="submenu">
                <li class="menu-item -level-2"><a class="link title  link-reactant-uiintroduction" href="../reactant-ui/introduction.html">Introduction</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-reactant-uilive-reload" href="../reactant-ui/live-reload.html">Live Reload</a>
                </li>
              </ul>
            </li>
            <li class="menu-item -level-1 -parent"><span class="title">Parts</span>
              <ul class="submenu">
                <li class="menu-item -level-2"><a class="link title  link-partsconfiguration" href="../parts/configuration.html">Configuration</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-partscontroller" href="../parts/controller.html">Controller</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-partsrootview" href="../parts/rootview.html">RootView</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-partswireframe" href="../parts/wireframe.html">Wireframe</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-partsstyling" href="../parts/styling.html">Styling</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-partstableview" href="../parts/tableview.html">TableView</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-partscollectionview" href="../parts/collectionview.html">CollectionView</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-partsvalidation" href="../parts/validation.html">Validation</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-partsactivityindicator" href="../parts/activityindicator.html">ActivityIndicator</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-partsstaticmap" href="../parts/staticmap.html">StaticMap</a>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </div>
      <div class="body page-getting-startedarchitecture">
        <div class="header-nav">
          <div class="right"><a class="iconlink" href="https://github.com/Brightify/Reactant" data-title="Brightify/Reactant">
              <!-- span.title Open in GitHub--><span class="icon -github"></span></a>
          </div>
        </div>
        <div class="markdown-body"><h1 id="architecture-walkthrough">Architecture Walkthrough</h1>
<p>We already talked about Components and Views in the <a href="quickstart.html">Quick-start</a>, but they alone are only a small part of <strong>Reactant</strong>. The magic comes when you embrace the whole architecture.</p>
<p>We recommend creating a new project and going along with us through this short guide before you venture out on your own. Creating a project compatible with Reactant requires a few steps.</p>
<ul>
<li>First, create a new <code>Single View Application</code> and select <code>Swift</code> as your application&#x2019;s language.</li>
<li>Once created, delete <code>Main.storyboard</code> and <code>ViewController.swift</code> files <strong>(Reactant does not support Storyboard/Interface Builder as classes are not accessible from ObjC runtime)</strong>.</li>
<li>Then open your app&#x2019;s target <code>General</code> settings and under <code>Deployment info</code> delete the value of <code>Main Interface</code> property.</li>
</ul>
<p>Next step is adding CocoaPods to the project. Open your project&#x2019;s directory in <em>Terminal</em> and run a <code>pod init</code> command. This will create a <code>Podfile</code> for you. Open it in a text editor and under your app&#x2019;s target add <code>pod &apos;Reactant&apos;</code>. The file should then look like this:</p>
<pre><code class="lang-ruby">platform <span class="hljs-symbol">:ios</span>, <span class="pl-s">&apos;9.0&apos;</span>

target <span class="pl-s">&apos;ReactantTutorial&apos;</span> <span class="pl-k">do</span>
  use_frameworks!

  pod <span class="pl-s">&apos;Reactant&apos;</span>
<span class="pl-k">end</span>
</code></pre>
<p>Once you save the file, pop up the <code>Terminal</code> again and run <code>pod install</code>. When the command completes, open the newly created <code>.xcworkspace</code>. Your project is now Reactant ready!</p>
<h2 id="recommended-directory-structure">Recommended directory structure</h2>
<p>Through this overview, you might be asking yourself what structure would be the best for this architecture. After many iterations we found one that goes well with Reactant and all its parts. However this structure is not mandatory, feel free to adjust it to your liking.</p>
<pre><code>YourProject/ (root directory with .xcodeproj)
&#x251C;&#x2500;&#x2500; Application/ (directory for the App target)
&#x2502;&#xA0;&#xA0; &#x251C;&#x2500;&#x2500; Generated/
&#x2502;&#xA0;&#xA0; &#x251C;&#x2500;&#x2500; Resources/ (here you&apos;ll put Assets.xcasset, Localizations etc.)
&#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; Sources/
&#x2502;&#xA0;&#xA0;     &#x251C;&#x2500;&#x2500; Components/
&#x2502;&#xA0;&#xA0;     &#x2502;&#xA0;&#xA0; &#x251C;&#x2500;&#x2500; SomeAppPart/
&#x2502;&#xA0;&#xA0;     &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0; &#x251C;&#x2500;&#x2500; SomeAppPartAction.swift
&#x2502;&#xA0;&#xA0;     &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0; &#x251C;&#x2500;&#x2500; SomeAppPartController.swift
&#x2502;&#xA0;&#xA0;     &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; SomeAppPartRootView.swift
&#x2502;&#xA0;&#xA0;     &#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; SomeOtherPart/
&#x2502;&#xA0;&#xA0;     &#x2502;&#xA0;&#xA0;     &#x251C;&#x2500;&#x2500; CustomView.swift
&#x2502;&#xA0;&#xA0;     &#x2502;&#xA0;&#xA0;     &#x251C;&#x2500;&#x2500; SomeOtherPartAction.swift
&#x2502;&#xA0;&#xA0;     &#x2502;&#xA0;&#xA0;     &#x251C;&#x2500;&#x2500; SomeOtherPartController.swift
&#x2502;&#xA0;&#xA0;     &#x2502;&#xA0;&#xA0;     &#x2514;&#x2500;&#x2500; SomeOtherPartRootView.swift
&#x2502;&#xA0;&#xA0;     &#x251C;&#x2500;&#x2500; Models/
&#x2502;&#xA0;&#xA0;     &#x251C;&#x2500;&#x2500; Services/
&#x2502;&#xA0;&#xA0;     &#x251C;&#x2500;&#x2500; Utils/
&#x2502;&#xA0;&#xA0;     &#x251C;&#x2500;&#x2500; Wireframes/
&#x2502;&#xA0;&#xA0;     &#x2514;&#x2500;&#x2500; AppDelegate.swift
&#x251C;&#x2500;&#x2500; Tests/ (directory for unit tests target, optional)
&#x2514;&#x2500;&#x2500; UITests/ (directory for ui tests target, optional)
</code></pre>
<h3 id="rootview">RootView</h3>
<p>View hierarchy starts with a <strong>RootView</strong>. It&#x2019;s nothing more than a special case of a view component, the only difference is that it&#x2019;s meant to fill the whole screen. <strong>RootView</strong> can contain other view components or it can consist of primitive views only (UILabel, UIButton etc.). Let&#x2019;s take our <code>GreeterView</code> from the previous example and make it a <strong>RootView</strong>.</p>
<pre><code class="lang-swift"><span class="pl-c">// GreeterRootView.swift</span>
<span class="pl-k">import</span> Reactant
<span class="pl-k">import</span> RxSwift

<span class="hljs-class"><span class="pl-k">enum</span> <span class="pl-ent">GreeterAction</span> </span>{
    <span class="pl-k">case</span> greetingChanged(<span class="hljs-type">String</span>)
}

<span class="pl-k">final</span> <span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">GreeterRootView</span>: <span class="pl-ent">ViewBase</span>&lt;(<span class="pl-ent">greeting</span>: <span class="pl-ent">String</span>, <span class="pl-ent">name</span>: <span class="pl-ent">String</span>), <span class="pl-ent">GreeterAction</span>&gt;, <span class="pl-ent">RootView</span> </span>{
    <span class="pl-k">override</span> <span class="pl-k">var</span> actions: [<span class="hljs-type">Observable</span>&lt;<span class="hljs-type">GreeterAction</span>&gt;] {
        <span class="pl-k">return</span> [
            nameField.action.<span class="pl-c1">map</span>(<span class="hljs-type">GreeterAction</span>.greetingChanged)
        ]
    }

    <span class="pl-k">private</span> <span class="pl-k">let</span> greeting = <span class="hljs-type">UILabel</span>()
    <span class="pl-k">private</span> <span class="pl-k">let</span> nameField = <span class="hljs-type">TextField</span>()

    <span class="pl-k">override</span> <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">update</span><span class="hljs-params">()</span></span> {
        greeting.text = componentState.greeting
        nameField.componentState = componentState.name
    }

    <span class="pl-k">override</span> <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">loadView</span><span class="hljs-params">()</span></span> {
        children(
            greeting,
            nameField
        )

        backgroundColor = .white
        greeting.textColor = .red
        nameField.placeholder = <span class="pl-s">&quot;Name to greet&quot;</span>
    }

    <span class="pl-k">override</span> <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">setupConstraints</span><span class="hljs-params">()</span></span> {
        greeting.snp.makeConstraints { make <span class="pl-k">in</span>
            make.<span class="pl-k">left</span>.top.<span class="pl-k">right</span>.equalToSuperview().inset(<span class="hljs-number">20</span>)
        }

        nameField.snp.makeConstraints { make <span class="pl-k">in</span>
            make.top.equalTo(greeting.snp.bottom).offset(<span class="hljs-number">10</span>)
            make.<span class="pl-k">left</span>.<span class="pl-k">right</span>.equalToSuperview().inset(<span class="hljs-number">20</span>)
            make.height.equalTo(<span class="hljs-number">50</span>)
        }
    }
}
</code></pre>
<p>Conformity to <code>RootView</code> protocol allows you to specify <code>edgesForExtendedLayout</code> and receive view events from Controller (<code>viewWillAppear</code>, <code>viewDidAppear</code>, <code>viewWillDisappear</code>, <code>viewDidDisappear</code>).</p>
<p>Other than that, <strong>RootViews</strong> are plain view components and your view doesn&#x2019;t have to conform to <code>RootView</code> to be used as a <strong>RootView</strong>.</p>
<h3 id="controller">Controller</h3>
<p>Each screen is a <strong>Controller</strong> and each <strong>Controller</strong> is a <strong>Component</strong>. Controllers in Reactant don&#x2019;t contain view logic. Their job is to obtain data (from API, database etc.) for their <strong>RootView</strong>&#x2019;s <code>componentState</code> and to receive and handle actions produced by said <strong>RootView</strong>. Let&#x2019;s create a controller for our <code>GreeterRootView</code>.</p>
<pre><code class="lang-swift"><span class="pl-c">// GreeterController.swift</span>
<span class="pl-k">import</span> Reactant

<span class="pl-k">final</span> <span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">GreeterController</span>: <span class="pl-ent">ControllerBase</span>&lt;<span class="pl-ent">Void</span>, <span class="pl-ent">GreeterRootView</span>&gt; </span>{
    <span class="pl-k">init</span>() {
        <span class="pl-k">super</span>.<span class="pl-k">init</span>(title: <span class="pl-s">&quot;Greeter&quot;</span>)

        <span class="pl-c">// An initial state for our rootView</span>
        rootView.componentState = (greeting: <span class="pl-s">&quot;&quot;</span> , name: <span class="pl-s">&quot;&quot;</span>)
    }

    <span class="pl-c">// Act on actions produced from RootView</span>
    <span class="pl-k">override</span> <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">act</span><span class="hljs-params">(on action: GreeterAction)</span></span> {
        <span class="pl-k">switch</span> action {
        <span class="pl-k">case</span> .greetingChanged(<span class="pl-k">let</span> greeting):
            rootView.componentState = (greeting: <span class="pl-s">&quot;Hello <span class="hljs-subst">\(greeting)</span>!&quot;</span>, name: greeting)
        }
    }
}
</code></pre>
<p>The <code>ControllerBase</code> class has two generic parameters, first one is the type of the Controller&#x2019;s <code>componentState</code> (Controllers can have a state too) and the second is the type of the <strong>RootView</strong>. The RootView is automatically initialized by the Controller, but you can do it manually by passing an instance of the RootView as <code>root</code> parameter of the Controller&#x2019;s initializer.</p>
<h2 id="dependency-injection-parameters-and-reactions">Dependency Injection, Parameters, and Reactions</h2>
<p>To be reusable and testable, Controller should get everything it needs from its caller. It&#x2019;s recommended that each Controller has the following inner structures (although not every Controller needs to have all three):</p>
<ul>
<li>Dependencies</li>
<li>Properties</li>
<li>Reactions</li>
</ul>
<p>Then you just add them as parameters in the Controller&#x2019;s <code>init</code> and store them to private properties so you can reference them later. An example Controller that would use all three of these would look like this:</p>
<pre><code class="lang-swift"><span class="pl-k">import</span> Reactant

<span class="pl-k">final</span> <span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">ExampleController</span>: <span class="pl-ent">ControllerBase</span>&lt;<span class="pl-ent">Void</span>, <span class="pl-ent">ExampleRootView</span>&gt; </span>{
    <span class="hljs-class"><span class="pl-k">struct</span> <span class="pl-ent">Dependencies</span> </span>{
        <span class="pl-k">let</span> someService: <span class="hljs-type">SomeService</span>
    }
    <span class="hljs-class"><span class="pl-k">struct</span> <span class="pl-ent">Properties</span> </span>{
        <span class="pl-k">let</span> userAccount: <span class="hljs-type">UserAccount</span>
    }
    <span class="hljs-class"><span class="pl-k">struct</span> <span class="pl-ent">Reactions</span> </span>{
        <span class="pl-k">let</span> openSettings: () -&gt; <span class="hljs-type">Void</span>
    }

    <span class="pl-k">private</span> <span class="pl-k">let</span> dependencies: <span class="hljs-type">Dependencies</span>
    <span class="pl-k">private</span> <span class="pl-k">let</span> properties: <span class="hljs-type">Properties</span>
    <span class="pl-k">private</span> <span class="pl-k">let</span> reactions: <span class="hljs-type">Reactions</span>

    <span class="pl-k">init</span>(dependencies: <span class="hljs-type">Dependencies</span>, properties: <span class="hljs-type">Properties</span>, reactions: <span class="hljs-type">Reactions</span>) {
        <span class="pl-k">self</span>.dependencies = dependencies
        <span class="pl-k">self</span>.properties = properties
        <span class="pl-k">self</span>.reactions = reactions
    }
}
</code></pre>
<p>We recommend keeping those three parameters alphabetically ordered, it&#x2019;s easiest to remember that way.</p>
<p>You might ask why not just pass the <code>someService</code>, <code>userAccount</code> and <code>openSettings</code> directly without those structures? Two reasons:</p>
<ul>
<li>as the project grows, your Controllers will need more dependencies, properties or reactions and when that happens, it&#x2019;s as easy as adding a new field into one of these structures and updating the call-sites to provide that new dependency</li>
<li>consistency, if you stick to the alphabetic order, you&#x2019;ll know what to expect</li>
</ul>
<p><strong>IMPORTANT</strong>: As you can see, the ExampleController knows nothing about any other Controller. That&#x2019;s an intended behavior and your Controllers should never know anything about navigation. If you need to close a Controller when a user taps a button, just add <code>let close: () -&gt; Void</code> reaction and let the caller handle the navigation. This is how you achieve perfect reusability and testability.</p>
<h2 id="service">Service</h2>
<p>Services are the place for business logic. They load, store and delete data. Such service might look like this example:</p>
<pre><code class="lang-swift"><span class="pl-c">// GreeterService.swift</span>
<span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">GreeterService</span> </span>{
    <span class="hljs-class"><span class="pl-k">enum</span> <span class="pl-ent">Language</span> </span>{
        <span class="pl-k">case</span> english
        <span class="pl-k">case</span> spanish
    }

    <span class="pl-k">private</span> <span class="pl-k">let</span> language: <span class="hljs-type">Language</span>

    <span class="pl-k">init</span>(language: <span class="hljs-type">Language</span>) {
        <span class="pl-k">self</span>.language = language
    }

    <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">greet</span><span class="hljs-params">(user: String)</span></span> -&gt; <span class="hljs-type">String</span> {
        <span class="pl-c">// We are not greeting an empty string</span>
        <span class="pl-k">guard</span> !user.isEmpty <span class="pl-k">else</span> { <span class="pl-k">return</span> <span class="pl-s">&quot;&quot;</span> }
        <span class="pl-k">switch</span> language {
        <span class="pl-k">case</span> .english:
            <span class="pl-k">return</span> <span class="pl-s">&quot;Hello <span class="hljs-subst">\(user)</span>!&quot;</span>
        <span class="pl-k">case</span> .spanish:
            <span class="pl-k">return</span> <span class="pl-s">&quot;&#xA1;Hola <span class="hljs-subst">\(user)</span>!&quot;</span>
        }
    }
}
</code></pre>
<p><strong>NOTE</strong>: For testing purposes, it&#x2019;s recommended that your Services are either defined as protocols or non-final classes. You&#x2019;ll then be able to mock them in your tests. For that we recommend you take a look at our mocking framework <a href="https://github.com/Brightify/Cuckoo">Cuckoo</a>.</p>
<h2 id="dependency-module">Dependency Module</h2>
<p>To have one place that decides on a concrete implementation of a dependency, you should have a Dependency Module. It&#x2019;s just a protocol, defining properties and methods used to obtain dependencies. You&#x2019;ll also have one or more implementations of this protocol. For example you could have one for Debug and one for Release configuration. Or one for the app and one for the tests, there are endless possibilities. Let&#x2019;s look at an example.</p>
<pre><code class="lang-swift"><span class="pl-c">// DependencyModule.swift</span>
<span class="hljs-class"><span class="pl-k">protocol</span> <span class="pl-ent">DependencyModule</span> </span>{
    <span class="pl-k">var</span> userService: <span class="hljs-type">UserService</span> { <span class="pl-k">get</span> }
    <span class="pl-k">var</span> anotherService: <span class="hljs-type">AnotherService</span> { <span class="pl-k">get</span> }

    <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">greeterService</span><span class="hljs-params">(language: GreeterService.Language)</span></span> -&gt; <span class="hljs-type">GreeterService</span>
}

<span class="pl-c">// ApplicationModule.swift (in Application target)</span>
<span class="pl-k">final</span> <span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">ApplicationModule</span>: <span class="pl-ent">DependencyModule</span> </span>{
    <span class="pl-k">let</span> userService: <span class="hljs-type">UserService</span> = <span class="hljs-type">AnUserServiceImplementation</span>()
    <span class="pl-k">var</span> anotherService: <span class="hljs-type">AnotherService</span> {
        <span class="pl-k">return</span> <span class="hljs-type">AnAnotherServiceImplementation</span>()
    }

    <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">greeterService</span><span class="hljs-params">(language: GreeterService.Language)</span></span> -&gt; <span class="hljs-type">GreeterService</span> {
        <span class="pl-k">return</span> <span class="hljs-type">GreeterService</span>(language: language)
    }
}

<span class="pl-c">// TestModule.swift (in Test target)</span>
<span class="pl-k">final</span> <span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">TestModule</span>: <span class="pl-ent">DependencyModule</span> </span>{
    <span class="pl-k">var</span> userService: <span class="hljs-type">UserService</span> {
        <span class="pl-k">return</span> <span class="hljs-type">StubUserService</span>()
    }
    <span class="pl-k">var</span> anotherService: <span class="hljs-type">AnotherService</span> {
        <span class="pl-k">return</span> <span class="hljs-type">StubAnotherService</span>()
    }

    <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">greeterService</span><span class="hljs-params">(language: GreeterService.Language)</span></span> -&gt; <span class="hljs-type">GreeterService</span> {
        <span class="pl-k">return</span> <span class="hljs-type">StubGreeterService</span>(language: language)
    }
}
</code></pre>
<p>Make sure that the types you specify in the DependencyModule protocol are the lowest possible. In our example we use <code>GreeterService</code> even though that&#x2019;s already an implementation we don&#x2019;t have any lower type to use.</p>
<p><strong>NOTE</strong>: The DependencyModule&#x2019;s lifecycle should be tied to the application (you should put it into a property in AppDelegate), the <code>userService</code> in the <code>AppModule</code> becomes a singleton.</p>
<p><strong>NOTE</strong>: Don&#x2019;t create unnecessary protocols for your dependencies until you need a protocol that would have at least two implementations. Having a protocol for each single implementation creates unnecessary boilerplate.</p>
<h2 id="wireframe">Wireframe</h2>
<p>Since Controllers don&#x2019;t know about navigation, there has to be something in the application that does. That something are Wireframes. Small applications can make do with a single one, but most of the time you&#x2019;ll have multiple Wireframes and each of them will take care of a specific part of the app. Wireframes should receive a Dependency Module with services, but instantiating Controllers is their responsibility. Reactant comes with a protocol <code>Wireframe</code> and we recommend taking advatange of the enhancements it provides. We&#x2019;ll get to an example, but first let&#x2019;s update our <code>GreeterController</code> to use a <code>GreeterService</code> and open URL when the greeted name is <code>Reactant</code>.</p>
<pre><code class="lang-swift"><span class="pl-c">// GreeterController.swift</span>
<span class="pl-k">import</span> Reactant

<span class="pl-k">final</span> <span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">GreeterController</span>: <span class="pl-ent">ControllerBase</span>&lt;<span class="pl-ent">String</span>, <span class="pl-ent">GreeterRootView</span>&gt; </span>{
    <span class="hljs-class"><span class="pl-k">struct</span> <span class="pl-ent">Dependencies</span> </span>{
        <span class="pl-k">let</span> greeterService: <span class="hljs-type">GreeterService</span>
    }
    <span class="hljs-class"><span class="pl-k">struct</span> <span class="pl-ent">Reactions</span> </span>{
        <span class="pl-k">let</span> openUrl: (<span class="hljs-type">URL</span>) -&gt; <span class="hljs-type">Void</span>
    }

    <span class="pl-k">private</span> <span class="pl-k">let</span> dependencies: <span class="hljs-type">Dependencies</span>
    <span class="pl-k">private</span> <span class="pl-k">let</span> reactions: <span class="hljs-type">Reactions</span>

    <span class="pl-k">init</span>(dependencies: <span class="hljs-type">Dependencies</span>, reactions: <span class="hljs-type">Reactions</span>) {
        <span class="pl-k">self</span>.dependencies = dependencies
        <span class="pl-k">self</span>.reactions = reactions

        <span class="pl-k">super</span>.<span class="pl-k">init</span>(title: <span class="pl-s">&quot;Greeter&quot;</span>)

        <span class="pl-c">// Set Controller&apos;s initial state</span>
        componentState = <span class="pl-s">&quot;&quot;</span>
    }

    <span class="pl-k">override</span> <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">update</span><span class="hljs-params">()</span></span> {
        rootView.componentState = (greeting: dependencies.greeterService.greet(user: componentState),
                                   name: componentState)
    }

    <span class="pl-c">// Act on actions produced from RootView</span>
    <span class="pl-k">override</span> <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">act</span><span class="hljs-params">(on action: GreeterAction)</span></span> {
        <span class="pl-k">switch</span> action {
        <span class="pl-k">case</span> .greetingChanged(<span class="pl-k">let</span> greeting):
            componentState = greeting

            <span class="pl-k">if</span> greeting == <span class="pl-s">&quot;Reactant&quot;</span> {
                reactions.openUrl(<span class="hljs-type">URL</span>(string: <span class="pl-s">&quot;http://reactant.tech&quot;</span>)!)
            }
        }
    }
}
</code></pre>
<p>You can see we also set <code>componentState</code> type to String in the Controller and added an <code>update()</code> method that sets <code>componentState</code> of the RootView. Let&#x2019;s now look at the wireframe.</p>
<pre><code class="lang-swift"><span class="pl-c">// MainWireframe.swift</span>
<span class="pl-k">import</span> UIKit
<span class="pl-k">import</span> Reactant

<span class="pl-k">final</span> <span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">MainWireframe</span>: <span class="pl-ent">Wireframe</span> </span>{
    <span class="pl-k">private</span> <span class="pl-k">let</span> module: <span class="hljs-type">DependencyModule</span>

    <span class="pl-k">init</span>(module: <span class="hljs-type">DependencyModule</span>) {
        <span class="pl-k">self</span>.module = module
    }

    <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">entrypoint</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">UIViewController</span> {
        <span class="pl-k">return</span> greeter(language: .english)
    }

    <span class="pl-k">private</span> <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">greeter</span><span class="hljs-params">(language: GreeterService.Language)</span></span> -&gt; <span class="hljs-type">GreeterController</span> {
        <span class="pl-k">return</span> create { <span class="hljs-number">_</span> <span class="pl-k">in</span>
            <span class="pl-k">let</span> dependencies = <span class="hljs-type">GreeterController</span>.<span class="hljs-type">Dependencies</span>(
                greeterService: module.greeterService(language: language)
            )
            <span class="pl-k">let</span> reactions = <span class="hljs-type">GreeterController</span>.<span class="hljs-type">Reactions</span>(
                openUrl: { url <span class="pl-k">in</span>
                    <span class="hljs-type">UIApplication</span>.shared.open(url)
                }
            )
            <span class="pl-k">return</span> <span class="hljs-type">GreeterController</span>(dependencies: dependencies, reactions: reactions)
        }
    }
}
</code></pre>
<p>Of course we still need to create a window, instantiate the <code>MainWireframe</code> and set result of <code>entrypoint()</code> method as the rootViewController. This is the job of AppDelegate, so let&#x2019;s do that now.</p>
<pre><code class="lang-swift"><span class="pl-c">// AppDelegate.swift</span>
<span class="pl-k">import</span> UIKit

<span class="hljs-meta">@UIApplicationMain</span>
<span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">AppDelegate</span> : <span class="pl-ent">UIResponder</span>, <span class="pl-ent">UIApplicationDelegate</span> </span>{
    <span class="pl-k">var</span> window : <span class="hljs-type">UIWindow</span>?

    <span class="pl-k">private</span> <span class="pl-k">let</span> module = <span class="hljs-type">ApplicationModule</span>()

    <span class="hljs-function"><span class="pl-k">func</span> <span class="pl-ent">application</span><span class="hljs-params">(<span class="hljs-number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]?)</span></span> -&gt; <span class="hljs-type">Bool</span> {
        <span class="pl-k">let</span> window = <span class="hljs-type">UIWindow</span>()
        <span class="pl-k">let</span> wireframe = <span class="hljs-type">MainWireframe</span>(module: module)
        window.rootViewController = wireframe.entrypoint()
        window.makeKeyAndVisible()
        <span class="pl-k">self</span>.window = window
        <span class="pl-k">return</span> <span class="pl-c1">true</span>
    }
}
</code></pre>
<p>To learn more about the <code>Wireframe</code> protocol and the mysterious <code>create</code> function, head to a page about <a href="../parts/wireframe.html">Wireframe</a>.</p>
<h2 id="final-result">Final result</h2>
<p>You can find the code for the complete example <a href="https://github.com/Brightify/ReactantTutorial">here</a>. To see a more impressive example, be sure to check out our simple travel planner app <a href="https://github.com/Brightify/Planie"><strong>Planie</strong></a></p>
<p>If you followed this guide, the app should open this screen <img src="../img/ReactantTutorial.png" alt="Reactant tutorial screen"></p>

        </div>
        <div class="footer-nav">
          <div class="left"><a href="../getting-started/quickstart.html"><span class="title">Quick-start guide</span></a></div>
          <div class="right"><a href="../getting-started/troubleshooting.html"><span class="label">Next: </span><span class="title">Troubleshooting</span></a></div>
        </div>
      </div>
    </div>
  </body>
</html>